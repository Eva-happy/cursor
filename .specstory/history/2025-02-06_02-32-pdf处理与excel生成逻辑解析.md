<!-- Generated by SpecStory -->

# PDF处理与Excel生成逻辑解析 (2025-02-06 10:32:25)

_**User**_

请问这个文件代码对于处理查找pdf和生成excel的逻辑是怎么样的呢

---

_**Assistant**_

我来为您解析这个文件中处理PDF和生成Excel的主要逻辑流程：

1. **PDF处理流程**：
主要在 `process_pdf_content` 和 `extract_table_from_pdf` 函数中实现：

```python
def process_pdf_content(driver, pdf_url, project_name=None):
    # 1. 下载PDF文件
    pdf_file = download_pdf(pdf_url, project_name)
    
    # 2. 提取表格数据
    all_pages_data = extract_table_from_pdf(pdf_file)
    
    # 3. 返回提取的数据
    return all_pages_data
```

具体PDF处理步骤：
- 使用 `pdfplumber` 库打开PDF文件
- 逐页处理，每页提取：
  - 标题信息
  - 执行时间
  - 表格数据
  - 注释信息
  - 单位信息
- 将每页数据存储为字典格式

2. **Excel生成流程**：
主要在 `write_to_excel` 函数中实现：

```python
def write_to_excel(all_pages_data, project_name=None):
    # 1. 创建Excel文件
    excel_file = os.path.join('downloads', f'{base_filename}V{version}.xlsx')
    writer = pd.ExcelWriter(excel_file, engine='openpyxl')
    
    # 2. 处理每一页数据
    for page_index in range(len(all_pages_data) - 1):
        # 处理电价表页面
        data, notes, calc_df = process_first_page(all_pages_data[page_index])
        
        # 写入数据到不同sheet
        sheet_name = f'电价表{page_index + 1}'
        data.to_excel(writer, sheet_name=sheet_name, index=False, startrow=3)
        
        # 设置格式（标题、合并单元格等）
        worksheet = writer.sheets[sheet_name]
        
        # 写入标题和单位信息
        # 合并空白单元格
        # 添加注释
        # 应用单元格格式
```

Excel生成的主要特点：
1. 自动创建带版本号的Excel文件
2. 每页数据创建独立的工作表
3. 保留原始格式：
   - 标题和副标题
   - 表格数据
   - 注释信息
   - 单位信息
4. 自动处理单元格合并：
   - 合并空白单元格
   - 保持数据的层级结构
   - 设置对齐方式和边框

3. **数据处理的特殊处理**：

```python
def merge_empty_cells(worksheet, start_row, end_row, start_col, end_col, header_row=None):
    # 处理单元格合并的逻辑：
    # 1. 优先处理第五行的横向合并
    # 2. 处理A-C列的横向合并
    # 3. 处理A-C列的纵向合并
    # 4. 处理其他列的纵向合并
```

主要功能：
- 智能识别需要合并的单元格
- 保持数据的层级结构
- 处理特殊格式要求
- 自动调整列宽
- 设置统一的样式

4. **错误处理和异常情况**：
- 文件不存在的处理
- 数据为空的处理
- 格式异常的处理
- 网络问题的处理

这个代码的设计考虑了：
1. 数据完整性：确保所有数据都被正确提取和保存
2. 格式保持：尽可能保持原始PDF的格式结构
3. 错误处理：完善的异常处理机制
4. 用户体验：生成的Excel文件易于阅读和使用

这样的处理流程确保了从PDF到Excel的转换既准确又保持了良好的可读性。

---

_**User**_

查找pdf的逻辑是怎么样呢

---

_**Assistant**_

让我为您详细解析查找PDF的逻辑流程：

1. **主要查找流程**：
在 `check_and_process_content` 函数中实现了PDF查找的主要逻辑：

```python
def check_and_process_content(driver, project_name=None):
    try:
        wait = WebDriverWait(driver, 2)
        
        # 1. 首先尝试查找普通的PDF iframe
        try:
            iframe = wait.until(
                EC.presence_of_element_located((By.XPATH, "//iframe[contains(@src, 'downloadFiles')]"))
            )
            pdf_url = iframe.get_attribute('src')
            
        except TimeoutException:
            # 2. 如果找不到普通PDF，尝试查找带链接的iframe
            iframe = wait.until(
                EC.presence_of_element_located((By.TAG_NAME, "iframe"))
            )
            driver.switch_to.frame(iframe)
            
            # 3. 查找并点击PDF链接
            link = wait.until(
                EC.element_to_be_clickable((By.TAG_NAME, "a"))
            )
            pdf_url = link.get_attribute('href')
            
            # 4. 点击链接并处理新窗口
            driver.execute_script("arguments[0].click();", link)
            driver.switch_to.default_content()
            time.sleep(2)
            
            # 5. 切换到新窗口
            current_window = driver.current_window_handle
            all_windows = driver.window_handles
            for window in all_windows:
                if window != current_window:
                    driver.switch_to.window(window)
                    break
```

2. **PDF下载逻辑**：
在 `download_pdf` 函数中实现：

```python
def download_pdf(pdf_url, project_name=None):
    try:
        # 1. 创建下载目录
        if not os.path.exists('downloads'):
            os.makedirs('downloads')
        
        # 2. 生成文件名（带版本号）
        base_filename = project_name if project_name else f'电价表_{datetime.now().strftime("%Y%m%d_%H%M%S")}'
        version = 1
        while True:
            pdf_file = os.path.join('downloads', f'{base_filename}V{version}.pdf')
            if not os.path.exists(pdf_file):
                break
            version += 1
        
        # 3. 设置请求头
        headers = {
            'User-Agent': 'Mozilla/5.0...',
            'Accept': 'application/pdf,*/*',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Referer': 'https://95598.csg.cn/'
        }
        
        # 4. 下载PDF
        session = requests.Session()
        session.verify = False
        response = session.get(pdf_url, headers=headers, timeout=30)
        
        # 5. 验证和保存文件
        if response.status_code == 200:
            content_type = response.headers.get('content-type', '').lower()
            content_length = len(response.content)
            
            if content_length > 0:
                with open(pdf_file, 'wb') as f:
                    f.write(response.content)
                
                # 验证保存的文件
                if os.path.exists(pdf_file) and os.path.getsize(pdf_file) > 0:
                    return pdf_file
```

3. **查找过程中的特殊处理**：

```python
# 1. 处理不同类型的PDF展示方式
try:
    # 直接嵌入的PDF
    iframe = wait.until(EC.presence_of_element_located((By.XPATH, "//iframe[contains(@src, 'downloadFiles')]")))
except TimeoutException:
    # 需要点击链接的PDF
    iframe = wait.until(EC.presence_of_element_located((By.TAG_NAME, "iframe")))

# 2. 处理新窗口的情况
current_window = driver.current_window_handle
all_windows = driver.window_handles
for window in all_windows:
    if window != current_window:
        driver.switch_to.window(window)
```

4. **查找流程的主要步骤**：

1. **页面导航**：
```python
# 在main函数中
driver.get("https://95598.csg.cn/#/gd/serviceInquire/information/list")
```

2. **选择省份和城市**：
```python
# 获取省份列表
provinces = get_provinces(driver)
selected_province = display_menu(provinces, "请选择省份：")

# 获取城市列表
cities = get_cities(driver)
selected_city = display_menu(cities, "请选择城市：")
```

3. **获取公告列表**：
```python
# 获取页码信息
total_pages = get_page_info(driver)

# 获取具体页面的公告
announcements = get_page_announcements(driver, page_choice)
```

4. **处理选中的公告**：
```python
# 点击选中的公告
wait_and_click_element(driver, selected_announcement['element'])

# 检查和处理PDF内容
excel_file = check_and_process_content(driver, selected_announcement['text'])
```

5. **错误处理机制**：
- 网络超时处理
- 文件不存在处理
- 内容验证
- 格式检查

这个查找PDF的逻辑设计考虑了：
1. **多样性**：处理不同形式的PDF展示方式
2. **稳定性**：完善的错误处理机制
3. **灵活性**：支持不同省份和城市的查询
4. **用户友好**：提供清晰的选择界面和提示信息

整个查找过程是一个层层递进的过程，从选择地区到最终定位到具体的PDF文件，每一步都有相应的错误处理和用户交互，确保了查找过程的可靠性和用户体验。

---



---

