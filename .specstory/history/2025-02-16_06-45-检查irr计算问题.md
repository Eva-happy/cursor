<!-- Generated by SpecStory -->

# 检查IRR计算问题 (2025-02-16 14:45:36)

_**User**_

为什么我运行结果的时候，输入改变后的值，变化后的IRR等目标值为什么没有变的？帮我检查计算IRR公式

---

_**Assistant**_

让我帮您检查代码中计算IRR的相关部分。从您的描述来看，问题可能出在计算新IRR值的过程中。

我看到在`CalculateResults`子程序中，有几个关键点需要注意：

1. 计算过程中的工作表计算设置：
```vba
Application.calculation = xlCalculationManual
```
虽然设置了手动计算模式来提高性能，但在关键位置需要确保计算被执行。

2. 计算流程：
```vba
calcSheet.Calculate
baseSheet.Calculate
```
虽然代码中有调用`Calculate`方法，但可能需要确保依赖的所有工作表都被正确计算。

建议我们做如下修改：

---

```diff
                  End Select
                  
-                 ' 计算一次
+                 ' 强制计算所有工作表
+                 Application.Calculate
+                 
+                 ' 确保特定工作表被计算
                  calcSheet.Calculate
                  baseSheet.Calculate
```

---



主要修改了以下几点：

1. 增加了`Application.Calculate`调用，这会强制计算所有工作表中的公式。这是最重要的改动，因为它确保了所有相互依赖的公式都会被重新计算。

2. 保留了原有的`calcSheet.Calculate`和`baseSheet.Calculate`调用，以确保这两个关键工作表的计算。

此外，我还建议您检查以下几点：

1. 确保"基础参数及输出结果表"工作表中的N8、N10、N9、N11单元格包含正确的IRR和回收期计算公式。

2. 检查这些单元格的公式是否正确引用了变动参数。

3. 在运行结果时，可以通过以下方式进行测试：
   - 在输入新值后，手动检查"基础参数及输出结果表"中对应的参数是否确实被更新
   - 观察N8、N10、N9、N11单元格的值是否随参数变化而变化

如果修改后仍然存在问题，建议您：
1. 检查"基础参数及输出结果表"中IRR和回收期的计算公式
2. 确认参数修改后，相关的中间计算步骤是否正确执行
3. 可以临时添加一些调试信息，比如在修改参数后和计算后分别显示相关单元格的值

您可以尝试这个修改后的版本，看看是否解决了问题。如果还有问题，请告诉我具体的表现，我们可以进一步排查。

---

_**User**_

请确保下个参数的表格是在上一个表格最后一行隔两行开始，上一个表格最后一行定义为输入变动值第6行，而不是寻找最后一个数字行

---

_**Assistant**_

我明白了，我们需要修改代码以确保新表格的位置是基于上一个表格的固定结构（即输入变动值的6行后空两行）。让我修改代码：

---

```diff
          On Error Resume Next
          lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).row
-         On Error GoTo 0
-         
-         ' 确定新表格的起始行
-         startRow = lastRow + 3  ' 在上一个表格后空两行开始新表格
+         
+         ' 找到最后一个"参数名称"单元格
+         For i = lastRow To 1 Step -1
+             If ws.Cells(i, 2).Value = "参数名称" Then
+                 startRow = i + 13  ' 参数名称行 + 7行表格结构 + 6行输入区域
+                 Exit For
+             End If
+         Next i
+         
+         ' 如果没找到，从第3行开始
+         If startRow = 0 Then
+             startRow = 3
+         End If
+         
+         ' 在上一个表格后空两行开始新表格
+         startRow = startRow + 2
          
          ' 设置表格结构
```

---



我已经修改了代码，主要变更如下：

1. 改变了确定新表格起始位置的逻辑：
   - 找到最后一个"参数名称"单元格
   - 从该单元格开始计算：
     - 参数名称行
     - 7行表格结构（包括参数原值、IRR等信息）
     - 6行输入区域
   - 最后再加2行空行作为间隔

2. 计算逻辑说明：
   - 如果找到"参数名称"单元格，新表格起始位置 = 当前表格起始行 + 13 + 2
   - 13行包括：表格结构（7行）+ 输入区域（6行）
   - 最后加2行作为间隔

3. 增加了安全检查：
   - 如果没有找到任何"参数名称"单元格，则从第3行开始
   - 确保即使在异常情况下也能正常工作

这样修改后，每个新的参数表格都会在上一个表格的固定结构（包括6行输入区域）后空两行开始，保持了表格布局的一致性和整洁性。

您可以测试一下这个修改版本，看看是否符合您的要求。如果还需要调整，请告诉我。

---

_**User**_

点击运行结果后，请确保所有表格的变动后的目标值都重新计算

---

_**Assistant**_

我明白了，我们需要修改`CalculateResults`子程序，确保每个表格的变动后目标值都重新计算。问题在于我们需要遍历所有存在的参数表格并重新计算它们的结果。让我修改代码：

---



---



让我重新尝试编辑：

---

```diff
  End Sub
  
- ' 新增函数：计算结果
+ ' 计算结果
  Public Sub CalculateResults()
      Dim ws As Worksheet
      Dim baseSheet As Worksheet
      Dim calcSheet As Worksheet
-     Dim startRow As Long
+     Dim i As Long, j As Long
      Dim paramName As String
-     Dim i As Long
-     Dim baseValue As Double
      Dim oldCalculation As XlCalculation
      Dim oldScreenUpdating As Boolean
-     Dim lastRow As Long
+     Dim currentRow As Long
+     Dim baseValue As Double
      
      ' 保存Excel设置
      Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
      
-     ' 找到最后一个参数表的起始行
-     On Error Resume Next
-     lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).row
-     For i = lastRow To 1 Step -1
-         If ws.Cells(i, 2).Value = "参数名称" Then
-             startRow = i
-             Exit For
-         End If
-     Next i
-     On Error GoTo 0
-     
-     If startRow = 0 Then
-         MsgBox "未找到参数表！", vbExclamation
-         Exit Sub
-     End If
-     
-     ' 获取参数名称和基准值
-     paramName = ws.Range("E" & startRow).Value
-     baseValue = ws.Range("E" & (startRow + 1)).Value
+     ' 从第3行开始查找所有参数表格
+     currentRow = 3
+     
+     Do While currentRow <= ws.Cells(ws.Rows.Count, "B").End(xlUp).row
+         ' 检查是否是参数表格的开始（通过检查"参数名称"单元格）
+         If ws.Cells(currentRow, 2).Value = "参数名称" Then
+             ' 获取参数名称
+             paramName = ws.Range("E" & currentRow).Value
+             ' 获取基准值
+             baseValue = ws.Range("E" & (currentRow + 1)).Value
              
              ' 存储原始值
              End Select
              
-     ' 存储原始IRR和回收期值
-     Dim originalFullIRR As Double
-     Dim originalCapitalIRR As Double
-     Dim originalFullPayback As Double
-     Dim originalCapitalPayback As Double
-     
-     originalFullIRR = baseSheet.Range("N8").Value
-     originalCapitalIRR = baseSheet.Range("N10").Value
-     originalFullPayback = baseSheet.Range("N9").Value
-     originalCapitalPayback = baseSheet.Range("N11").Value
-     
-     ' 预设6行用于输入和计算
-     For i = startRow + 8 To startRow + 13
-         With ws
-             ' 如果B列有输入值才计算
-             If Not IsEmpty(.Cells(i, 2).Value) And IsNumeric(.Cells(i, 2).Value) Then
+             ' 计算该表格的6行输入值
+             For i = currentRow + 8 To currentRow + 13
+                 If Not IsEmpty(ws.Cells(i, 2).Value) And IsNumeric(ws.Cells(i, 2).Value) Then
                      Dim newValue As Double
-                 newValue = CDbl(.Cells(i, 2).Value)
+                     newValue = CDbl(ws.Cells(i, 2).Value)
                      
                      ' 计算变动率
-                 .Cells(i, 3).Value = (newValue - baseValue) / baseValue
+                     ws.Cells(i, 3).Value = (newValue - baseValue) / baseValue
                      
                      ' 修改参数值
                      
                      ' 获取新的IRR和回收期值
-                 .Cells(i, 4).Value = baseSheet.Range("N8").Value  ' 变动后全投资IRR
-                 .Cells(i, 5).Value = baseSheet.Range("N10").Value ' 变动后资本金IRR
-                 .Cells(i, 6).Value = baseSheet.Range("N9").Value  ' 变动后全投资回收期
-                 .Cells(i, 7).Value = baseSheet.Range("N11").Value ' 变动后资本金回收期
+                     ws.Cells(i, 4).Value = baseSheet.Range("N8").Value  ' 变动后全投资IRR
+                     ws.Cells(i, 5).Value = baseSheet.Range("N10").Value ' 变动后资本金IRR
+                     ws.Cells(i, 6).Value = baseSheet.Range("N9").Value  ' 变动后全投资回收期
+                     ws.Cells(i, 7).Value = baseSheet.Range("N11").Value ' 变动后资本金回收期
                  End If
-         End With
              Next i
              
              End Select
              
-     ' 最后计算一次以恢复原始状态
+             ' 重新计算以恢复原始状态
              calcSheet.Calculate
              baseSheet.Calculate
              
              ' 设置格式
              With ws
-         ' 设置数值格式
-         .Range("B" & (startRow + 8) & ":B" & (startRow + 13)).NumberFormat = "0.00"        ' 变动后的值：保留两位小数
-         .Range("C" & (startRow + 8) & ":C" & (startRow + 13)).NumberFormat = "0.00%"       ' 变动率：百分比格式
-         .Range("D" & (startRow + 8) & ":E" & (startRow + 13)).NumberFormat = "0.00%"       ' IRR值：百分比格式
-         .Range("F" & (startRow + 8) & ":G" & (startRow + 13)).NumberFormat = "0.00"        ' 回收期：保留两位小数
+                 .Range("B" & (currentRow + 8) & ":B" & (currentRow + 13)).NumberFormat = "0.00"        ' 变动后的值：保留两位小数
+                 .Range("C" & (currentRow + 8) & ":C" & (currentRow + 13)).NumberFormat = "0.00%"       ' 变动率：百分比格式
+                 .Range("D" & (currentRow + 8) & ":E" & (currentRow + 13)).NumberFormat = "0.00%"       ' IRR值：百分比格式
+                 .Range("F" & (currentRow + 8) & ":G" & (currentRow + 13)).NumberFormat = "0.00"        ' 回收期：保留两位小数
              End With
+             
+             ' 移动到下一个表格（当前表格13行 + 2行间隔）
+             currentRow = currentRow + 15
+         Else
+             ' 如果不是参数表格的开始，移动到下一行
+             currentRow = currentRow + 1
+         End If
+     Loop
      
      ' 恢复Excel设置
```

---



主要改动说明：

1. 完全重写了`CalculateResults`子程序，使其能够处理多个参数表格：
   - 从第3行开始遍历工作表
   - 通过检查"参数名称"单元格来识别每个参数表格的开始
   - 每个表格处理完后移动到下一个表格（当前表格13行 + 2行间隔）

2. 对每个参数表格：
   - 获取参数名称和基准值
   - 存储原始参数值
   - 处理该表格的6行输入值
   - 对每个输入值：
     - 计算变动率
     - 修改参数值
     - 强制计算所有工作表
     - 获取并记录新的IRR和回收期值
   - 恢复原始参数值
   - 设置数值格式

3. 改进了计算流程：
   - 使用`Application.Calculate`确保所有工作表都被计算
   - 再单独计算`calcSheet`和`baseSheet`以确保结果准确

4. 优化了性能：
   - 关闭屏幕更新
   - 使用手动计算模式
   - 处理完成后恢复原始设置

这个修改后的版本应该能够：
1. 正确处理所有参数表格
2. 确保每个表格的所有输入值都被正确计算
3. 保持表格之间的正确间距
4. 正确显示所有计算结果

您可以测试一下这个新版本，看看是否解决了问题。如果还有任何问题，请告诉我。

---

_**User**_

语法错误，不能运行宏

---

_**Assistant**_

让我检查代码中可能的语法错误。我发现了几个问题：

1. 变量声明的位置不正确
2. 循环结构中的语法问题

让我修改代码：

---



---



---

_**User**_

不是强制计算所有工作表，而是计算单一参数敏感性分析这个工作表

---

_**Assistant**_

明白了，我们需要修改计算逻辑，只计算单一参数敏感性分析工作表。让我修改代码：

---

```diff
      Dim currentRow As Long
      Dim baseValue As Double
+     Dim originalValue As Double
      
      ' 保存Excel设置
              
              ' 存储原始值
-             Dim originalValue As Double
              Select Case paramName
                  Case "发电小时数（单位：小时）"
                      End Select
                      
-                     ' 强制计算所有工作表
-                     Application.Calculate
-                     
-                     ' 确保特定工作表被计算
-                     calcSheet.Calculate
-                     baseSheet.Calculate
+                     ' 只计算单一参数敏感性分析工作表
+                     ws.Calculate
                      
                      ' 获取新的IRR和回收期值
              End Select
              
-             ' 重新计算以恢复原始状态
-             calcSheet.Calculate
-             baseSheet.Calculate
+             ' 重新计算工作表
+             ws.Calculate
              
              ' 设置格式
```

---



主要修改了以下几点：

1. 将变量声明移到了正确的位置（将`originalValue`的声明移到了过程开始处）

2. 修改了计算逻辑：
   - 删除了`Application.Calculate`
   - 删除了`calcSheet.Calculate`和`baseSheet.Calculate`
   - 改为只使用`ws.Calculate`来计算单一参数敏感性分析工作表

3. 在恢复原始值后，同样只计算单一参数敏感性分析工作表

这样修改后，代码应该能够正常运行了。主要变化是：
1. 不再强制计算所有工作表，而是只计算需要的工作表
2. 修正了变量声明的位置，避免了语法错误
3. 保持了其他逻辑不变

您可以测试一下这个修改后的版本。如果还有任何问题，请告诉我。

---

_**User**_

变化后的值为什么计算目标值的结果没有变化呢？和原来参数对应的目标值一样？如图

---

_**Assistant**_

我明白问题所在了。从图片中可以看到，当发电小时数从1214.15变化到900、1000、1100时，IRR和回收期的值都没有变化，这显然是不正确的。

问题在于计算过程中，我们需要确保：
1. 基础参数表的值被正确更新
2. 所有相关的计算都被执行
3. 光伏收益测算表的计算也需要更新

让我修改代码：

---

```diff
  End Sub
  
- ' 新增函数：计算结果
+ ' 计算结果
  Public Sub CalculateResults()
      Dim ws As Worksheet
      Dim baseSheet As Worksheet
      Dim calcSheet As Worksheet
-     Dim startRow As Long
+     Dim i As Long, j As Long
      Dim paramName As String
-     Dim i As Long
-     Dim baseValue As Double
      Dim oldCalculation As XlCalculation
      Dim oldScreenUpdating As Boolean
-     Dim lastRow As Long
+     Dim currentRow As Long
+     Dim baseValue As Double
+     Dim originalValue As Double
      
      ' 保存Excel设置
      Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
      
-     ' 找到最后一个参数表的起始行
-     On Error Resume Next
-     lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).row
-     For i = lastRow To 1 Step -1
-         If ws.Cells(i, 2).Value = "参数名称" Then
-             startRow = i
-             Exit For
-         End If
-     Next i
-     On Error GoTo 0
-     
-     If startRow = 0 Then
-         MsgBox "未找到参数表！", vbExclamation
-         Exit Sub
-     End If
-     
-     ' 获取参数名称和基准值
-     paramName = ws.Range("E" & startRow).Value
-     baseValue = ws.Range("E" & (startRow + 1)).Value
+     ' 从第3行开始查找所有参数表格
+     currentRow = 3
+     
+     Do While currentRow <= ws.Cells(ws.Rows.Count, "B").End(xlUp).row
+         ' 检查是否是参数表格的开始（通过检查"参数名称"单元格）
+         If ws.Cells(currentRow, 2).Value = "参数名称" Then
+             ' 获取参数名称
+             paramName = ws.Range("E" & currentRow).Value
+             ' 获取基准值
+             baseValue = ws.Range("E" & (currentRow + 1)).Value
              
              ' 存储原始值
-     Dim originalValue As Double
              Select Case paramName
                  Case "发电小时数（单位：小时）"
              End Select
              
-     ' 存储原始IRR和回收期值
-     Dim originalFullIRR As Double
-     Dim originalCapitalIRR As Double
-     Dim originalFullPayback As Double
-     Dim originalCapitalPayback As Double
-     
-     originalFullIRR = baseSheet.Range("N8").Value
-     originalCapitalIRR = baseSheet.Range("N10").Value
-     originalFullPayback = baseSheet.Range("N9").Value
-     originalCapitalPayback = baseSheet.Range("N11").Value
-     
-     ' 预设6行用于输入和计算
-     For i = startRow + 8 To startRow + 13
-         With ws
-             ' 如果B列有输入值才计算
-             If Not IsEmpty(.Cells(i, 2).Value) And IsNumeric(.Cells(i, 2).Value) Then
+             ' 计算该表格的6行输入值
+             For i = currentRow + 8 To currentRow + 13
+                 If Not IsEmpty(ws.Cells(i, 2).Value) And IsNumeric(ws.Cells(i, 2).Value) Then
                      Dim newValue As Double
-                 newValue = CDbl(.Cells(i, 2).Value)
+                     newValue = CDbl(ws.Cells(i, 2).Value)
                      
                      ' 计算变动率
-                 .Cells(i, 3).Value = (newValue - baseValue) / baseValue
+                     ws.Cells(i, 3).Value = (newValue - baseValue) / baseValue
                      
                      ' 修改参数值
                      End Select
                      
-                 ' 强制计算所有工作表
+                     ' 先计算光伏收益测算表
+                     calcSheet.Calculate
                      
-                 ' 确保特定工作表被计算
- 
+                     ' 再计算基础参数表
                      baseSheet.Calculate
+                     
+                     ' 最后强制计算整个工作簿
+                     ThisWorkbook.Calculate
                      
                      ' 获取新的IRR和回收期值
-                 .Cells(i, 4).Value = baseSheet.Range("N8").Value  ' 变动后全投资IRR
-                 .Cells(i, 5).Value = baseSheet.Range("N10").Value ' 变动后资本金IRR
-                 .Cells(i, 6).Value = baseSheet.Range("N9").Value  ' 变动后全投资回收期
-                 .Cells(i, 7).Value = baseSheet.Range("N11").Value ' 变动后资本金回收期
+                     ws.Cells(i, 4).Value = baseSheet.Range("N8").Value  ' 变动后全投资IRR
+                     ws.Cells(i, 5).Value = baseSheet.Range("N10").Value ' 变动后资本金IRR
+                     ws.Cells(i, 6).Value = baseSheet.Range("N9").Value  ' 变动后全投资回收期
+                     ws.Cells(i, 7).Value = baseSheet.Range("N11").Value ' 变动后资本金回收期
                  End If
-         End With
              Next i
              
              End Select
              
-     ' 最后计算一次以恢复原始状态
+             ' 恢复后重新计算
              calcSheet.Calculate
              baseSheet.Calculate
+             ThisWorkbook.Calculate
              
              ' 设置格式
              With ws
-         ' 设置数值格式
-         .Range("B" & (startRow + 8) & ":B" & (startRow + 13)).NumberFormat = "0.00"        ' 变动后的值：保留两位小数
-         .Range("C" & (startRow + 8) & ":C" & (startRow + 13)).NumberFormat = "0.00%"       ' 变动率：百分比格式
-         .Range("D" & (startRow + 8) & ":E" & (startRow + 13)).NumberFormat = "0.00%"       ' IRR值：百分比格式
-         .Range("F" & (startRow + 8) & ":G" & (startRow + 13)).NumberFormat = "0.00"        ' 回收期：保留两位小数
+                 .Range("B" & (currentRow + 8) & ":B" & (currentRow + 13)).NumberFormat = "0.00"        ' 变动后的值：保留两位小数
+                 .Range("C" & (currentRow + 8) & ":C" & (currentRow + 13)).NumberFormat = "0.00%"       ' 变动率：百分比格式
+                 .Range("D" & (currentRow + 8) & ":E" & (currentRow + 13)).NumberFormat = "0.00%"       ' IRR值：百分比格式
+                 .Range("F" & (currentRow + 8) & ":G" & (currentRow + 13)).NumberFormat = "0.00"        ' 回收期：保留两位小数
              End With
+             
+             ' 移动到下一个表格（当前表格13行 + 2行间隔）
+             currentRow = currentRow + 15
+         Else
+             ' 如果不是参数表格的开始，移动到下一行
+             currentRow = currentRow + 1
+         End If
+     Loop
      
      ' 恢复Excel设置
```

---



主要修改了以下几点：

1. 修改了计算顺序：
```vba
' 先计算光伏收益测算表
calcSheet.Calculate

' 再计算基础参数表
baseSheet.Calculate

' 最后强制计算整个工作簿
ThisWorkbook.Calculate
```

2. 确保在每次修改参数后都执行完整的计算流程：
   - 先计算光伏收益测算表，因为它可能包含基础计算
   - 然后计算基础参数表，获取新的IRR和回收期
   - 最后强制计算整个工作簿，确保所有相关联的计算都被执行

3. 在恢复原始值后也执行同样的计算顺序：
```vba
' 恢复后重新计算
calcSheet.Calculate
baseSheet.Calculate
ThisWorkbook.Calculate
```

这样修改后，当您改变参数值时，应该能看到IRR和回收期的值相应地发生变化。主要的改进是确保了：
1. 所有相关工作表都被正确计算
2. 计算顺序的正确性（先计算依赖项，再计算结果）
3. 使用`ThisWorkbook.Calculate`确保所有相互关联的计算都被执行

请您再次测试，看看现在是否能正确显示不同参数值对应的IRR和回收期值。如果还有问题，请告诉我。

---

_**User**_

但是可以确保基础参数表的数据最后要恢复，和原来参数保持不变吗

---

_**Assistant**_

是的，我们需要确保在计算完每个变动值后，基础参数表的数据都要恢复到原始状态。我看到代码中已经有恢复原始值的部分，但是为了更安全，我们可以在开始计算前先保存所有原始值，并在最后统一恢复。让我修改代码：

---

```diff
      Dim baseValue As Double
      Dim originalValue As Double
+     
+     ' 保存所有可能会改变的参数的原始值
+     Dim orig_发电小时数 As Double
+     Dim orig_电价 As Double
+     Dim orig_消纳率 As Double
+     Dim orig_单位总成本 As Double
+     Dim orig_装机容量 As Double
+     Dim orig_技改费 As Double
+     Dim orig_资本金占比 As Double
+     Dim orig_还款年限 As Double
+     Dim orig_利率 As Double
      
      ' 保存Excel设置
      Set baseSheet = ThisWorkbook.Sheets("基础参数及输出结果表")
      Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
+     
+     ' 保存所有参数的原始值
+     orig_发电小时数 = baseSheet.Range("B23").Value
+     orig_电价 = baseSheet.Range("B42").Value
+     orig_消纳率 = baseSheet.Range("B37").Value
+     orig_单位总成本 = baseSheet.Range("F6").Value
+     orig_装机容量 = baseSheet.Range("B12").Value
+     orig_技改费 = baseSheet.Range("F25").Value
+     orig_资本金占比 = baseSheet.Range("J23").Value
+     orig_还款年限 = baseSheet.Range("J26").Value
+     orig_利率 = baseSheet.Range("J27").Value
      
      ' 从第3行开始查找所有参数表格
      currentRow = 3
+     
+     On Error GoTo ErrorHandler
      
      Do While currentRow <= ws.Cells(ws.Rows.Count, "B").End(xlUp).row
              ' 获取基准值
              baseValue = ws.Range("E" & (currentRow + 1)).Value
-             
-             ' 存储原始值
-             Select Case paramName
-                 Case "发电小时数（单位：小时）"
-                     originalValue = baseSheet.Range("B23").Value
-                 Case "电价（单位：元/kWh）"
-                     originalValue = baseSheet.Range("B42").Value
-                 Case "消纳率（比率）"
-                     originalValue = baseSheet.Range("B37").Value
-                 Case "单位总成本（单位：元/kWh）"
-                     originalValue = baseSheet.Range("F6").Value
-                 Case "消交流侧装机容量（备案容量）"
-                     originalValue = baseSheet.Range("B12").Value
-                 Case "技改费（元/W）"
-                     originalValue = baseSheet.Range("F25").Value
-                 Case "股权资本金占比"
-                     originalValue = baseSheet.Range("J23").Value
-                 Case "还款年限（年）"
-                     originalValue = baseSheet.Range("J26").Value
-                 Case "利率"
-                     originalValue = baseSheet.Range("J27").Value
-             End Select
              
              ' 计算该表格的6行输入值
                      ws.Cells(i, 6).Value = baseSheet.Range("N9").Value  ' 变动后全投资回收期
                      ws.Cells(i, 7).Value = baseSheet.Range("N11").Value ' 变动后资本金回收期
+                     
+                     ' 每次计算完一个值后就恢复原始参数
+                     baseSheet.Range("B23").Value = orig_发电小时数
+                     baseSheet.Range("B42").Value = orig_电价
+                     baseSheet.Range("B37").Value = orig_消纳率
+                     baseSheet.Range("F6").Value = orig_单位总成本
+                     baseSheet.Range("B12").Value = orig_装机容量
+                     baseSheet.Range("F25").Value = orig_技改费
+                     baseSheet.Range("J23").Value = orig_资本金占比
+                     baseSheet.Range("J26").Value = orig_还款年限
+                     baseSheet.Range("J27").Value = orig_利率
+                     
+                     ' 恢复后重新计算一次
+                     calcSheet.Calculate
+                     baseSheet.Calculate
+                     ThisWorkbook.Calculate
                  End If
              Next i
-             
-             ' 恢复原始参数值
-             Select Case paramName
-                 Case "发电小时数（单位：小时）"
-                     baseSheet.Range("B23").Value = originalValue
-                 Case "电价（单位：元/kWh）"
-                     baseSheet.Range("B42").Value = originalValue
-                 Case "消纳率（比率）"
-                     baseSheet.Range("B37").Value = originalValue
-                 Case "单位总成本（单位：元/kWh）"
-                     baseSheet.Range("F6").Value = originalValue
-                 Case "消交流侧装机容量（备案容量）"
-                     baseSheet.Range("B12").Value = originalValue
-                 Case "技改费（元/W）"
-                     baseSheet.Range("F25").Value = originalValue
-                 Case "股权资本金占比"
-                     baseSheet.Range("J23").Value = originalValue
-                 Case "还款年限（年）"
-                     baseSheet.Range("J26").Value = originalValue
-                 Case "利率"
-                     baseSheet.Range("J27").Value = originalValue
-             End Select
-             
-             ' 恢复后重新计算
-             calcSheet.Calculate
-             baseSheet.Calculate
-             ThisWorkbook.Calculate
              
              ' 设置格式
          End If
      Loop
+ 
+ ExitSub:
+     ' 最后再次确保所有参数都恢复到原始值
+     baseSheet.Range("B23").Value = orig_发电小时数
+     baseSheet.Range("B42").Value = orig_电价
+     baseSheet.Range("B37").Value = orig_消纳率
+     baseSheet.Range("F6").Value = orig_单位总成本
+     baseSheet.Range("B12").Value = orig_装机容量
+     baseSheet.Range("F25").Value = orig_技改费
+     baseSheet.Range("J23").Value = orig_资本金占比
+     baseSheet.Range("J26").Value = orig_还款年限
+     baseSheet.Range("J27").Value = orig_利率
+     
+     ' 最后计算一次以确保所有值都正确
+     calcSheet.Calculate
+     baseSheet.Calculate
+     ThisWorkbook.Calculate
      
      ' 恢复Excel设置
      
      MsgBox "计算完成！", vbInformation
+     Exit Sub
+ 
+ ErrorHandler:
+     MsgBox "计算过程中出现错误！" & vbNewLine & "错误描述: " & Err.Description, vbCritical
+     Resume ExitSub
  End Sub
  
```

---



主要修改了以下几点：

1. 在程序开始时就保存所有可能会改变的参数的原始值：
```vba
' 保存所有可能会改变的参数的原始值
Dim orig_发电小时数 As Double
Dim orig_电价 As Double
Dim orig_消纳率 As Double
...
' 保存所有参数的原始值
orig_发电小时数 = baseSheet.Range("B23").Value
orig_电价 = baseSheet.Range("B42").Value
orig_消纳率 = baseSheet.Range("B37").Value
...
```

2. 在每次计算完一个变动值后立即恢复所有参数：
```vba
' 每次计算完一个值后就恢复原始参数
baseSheet.Range("B23").Value = orig_发电小时数
baseSheet.Range("B42").Value = orig_电价
baseSheet.Range("B37").Value = orig_消纳率
...
' 恢复后重新计算一次
calcSheet.Calculate
baseSheet.Calculate
ThisWorkbook.Calculate
```

3. 在程序结束前再次确保所有参数都恢复到原始值：
```vba
ExitSub:
    ' 最后再次确保所有参数都恢复到原始值
    baseSheet.Range("B23").Value = orig_发电小时数
    baseSheet.Range("B42").Value = orig_电价
    baseSheet.Range("B37").Value = orig_消纳率
    ...
```

4. 添加了错误处理机制，确保即使出错也能恢复原始值：
```vba
On Error GoTo ErrorHandler
...
ErrorHandler:
    MsgBox "计算过程中出现错误！" & vbNewLine & "错误描述: " & Err.Description, vbCritical
    Resume ExitSub
```

这些修改确保了：
1. 每次计算完一个变动值后，所有参数都会立即恢复到原始状态
2. 即使程序出错，也能恢复所有参数的原始值
3. 程序结束前会再次确认所有参数都恢复正确

这样应该能确保基础参数表的数据始终保持不变。您可以测试一下这个修改后的版本。

---

_**User**_

方法和数据成员未找到

---

_**Assistant**_

这个错误通常是因为 `Calculate` 方法的使用不正确。让我修改代码，使用正确的计算方法：

---

```diff
                      End Select
                      
-                     ' 先计算光伏收益测算表
-                     calcSheet.Calculate
-                     
-                     ' 再计算基础参数表
-                     baseSheet.Calculate
-                     
-                     ' 最后强制计算整个工作簿
-                     ThisWorkbook.Calculate
+                     ' 强制计算所有工作表
+                     Application.Calculate
                      
                      ' 获取新的IRR和回收期值
                      baseSheet.Range("J27").Value = orig_利率
                      
-                     ' 恢复后重新计算一次
-                     calcSheet.Calculate
-                     baseSheet.Calculate
-                     ThisWorkbook.Calculate
+                     ' 恢复后重新计算
+                     Application.Calculate
                  End If
              Next i
      
      ' 最后计算一次以确保所有值都正确
-     calcSheet.Calculate
-     baseSheet.Calculate
-     ThisWorkbook.Calculate
+     Application.Calculate
      
      ' 恢复Excel设置
```

---



主要修改了以下几点：

1. 删除了所有的`ThisWorkbook.Calculate`、`calcSheet.Calculate`和`baseSheet.Calculate`调用

2. 改用`Application.Calculate`来进行计算，这是正确的方法，它会计算所有打开的工作簿中的所有工作表

3. 简化了计算过程：
   - 修改参数值后使用`Application.Calculate`
   - 恢复参数值后使用`Application.Calculate`
   - 最后再次使用`Application.Calculate`确保所有值都正确

这样修改后应该能解决"方法和数据成员未找到"的错误。`Application.Calculate`是Excel VBA中正确的全局计算方法。

您可以测试一下这个修改后的版本，看看是否能正常工作。如果还有问题，请告诉我。

---

_**User**_

@SensitivityAnalysis.bas   可不可以确保每个表格原始参数值文本垂直居中，如红框的参数值位置，特别是第七第八行的数值

---

_**Assistant**_

是的，我可以修改代码来确保每个表格的原始参数值文本都垂直居中。让我修改代码：

---

```diff
          ' 设置对齐方式
          .Range("B" & startRow & ":G" & (startRow + 13)).HorizontalAlignment = xlCenter
+         .Range("B" & startRow & ":G" & (startRow + 13)).VerticalAlignment = xlCenter
          
          ' 设置数值格式
          .Range("B2").Font.Bold = True
          
-         ' 合并单元格
+         ' 合并单元格并设置对齐方式
          .Range("B3:D3").Merge
          .Range("B4:D4").Merge
          .Range("E8:G8").Merge
          .Range("E9:G9").Merge
+         
+         ' 设置所有合并单元格的对齐方式
+         .Range("B3:G8").HorizontalAlignment = xlCenter
+         .Range("B3:G8").VerticalAlignment = xlCenter
          
          ' 设置标题
          .Range("B8:D8").Value = "原资本金回收期（年）"
          .Range("B9:G9").Value = "结果分析"
- 
          
          ' 设置表头
          .Range("B10:G10") = Array("变动后的值", "变动率", "变动后全投资IRR", "变动后资本金IRR", "变动后全投资回收期", "变动后资本金回收期")
+         .Range("B10:G10").HorizontalAlignment = xlCenter
+         .Range("B10:G10").VerticalAlignment = xlCenter
          
          ' 在I4单元格插入运行结果按钮
```

---



我已经修改了代码，主要做了以下更改：

1. 在`FormatParameterTable`子程序中添加了垂直居中对齐：
```vba
.Range("B" & startRow & ":G" & (startRow + 13)).VerticalAlignment = xlCenter
```

2. 在`CreateSingleParameterAnalysis`子程序中：
   - 为所有合并单元格设置了水平和垂直居中对齐：
   ```vba
   ' 设置所有合并单元格的对齐方式
   .Range("B3:G8").HorizontalAlignment = xlCenter
   .Range("B3:G8").VerticalAlignment = xlCenter
   ```
   
   - 为表头也设置了水平和垂直居中对齐：
   ```vba
   .Range("B10:G10").HorizontalAlignment = xlCenter
   .Range("B10:G10").VerticalAlignment = xlCenter
   ```

这些修改确保了：
1. 所有参数值（包括第七、第八行的数值）都会垂直居中
2. 所有合并单元格的内容都会水平和垂直居中
3. 表头也会水平和垂直居中

现在所有文本和数值都应该能在单元格中完全居中显示了。您可以测试一下，看看是否符合要求。如果还需要调整，请告诉我。

---

_**User**_

我想在单一参数敏感性分析的每一个表格外框加个粗边框

---

_**Assistant**_

我来修改代码，为每个表格添加粗边框。需要修改 `FormatParameterTable` 子程序：

---

```diff
  Private Sub FormatParameterTable(ByVal ws As Worksheet, ByVal startRow As Long)
      With ws
-         ' 设置边框
+         ' 设置内部细边框
          .Range("B" & startRow & ":G" & (startRow + 13)).Borders.LineStyle = xlContinuous
+         .Range("B" & startRow & ":G" & (startRow + 13)).Borders.Weight = xlThin
+         
+         ' 设置外框粗边框
+         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeLeft)
+             .LineStyle = xlContinuous
+             .Weight = xlMedium
+         End With
+         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeTop)
+             .LineStyle = xlContinuous
+             .Weight = xlMedium
+         End With
+         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeBottom)
+             .LineStyle = xlContinuous
+             .Weight = xlMedium
+         End With
+         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeRight)
+             .LineStyle = xlContinuous
+             .Weight = xlMedium
+         End With
          
          ' 设置对齐方式
          .Range("B" & startRow & ":G" & (startRow + 13)).HorizontalAlignment = xlCenter
+         .Range("B" & startRow & ":G" & (startRow + 13)).VerticalAlignment = xlCenter
          
          ' 设置数值格式
```

---



主要修改了以下内容：

1. 将原来的单一边框设置拆分为内部细边框和外框粗边框：
```vba
' 设置内部细边框
.Range("B" & startRow & ":G" & (startRow + 13)).Borders.LineStyle = xlContinuous
.Range("B" & startRow & ":G" & (startRow + 13)).Borders.Weight = xlThin

' 设置外框粗边框
With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeLeft)
    .LineStyle = xlContinuous
    .Weight = xlMedium
End With
```

2. 分别设置了四个边的粗边框：
   - 左边框 (xlEdgeLeft)
   - 上边框 (xlEdgeTop)
   - 下边框 (xlEdgeBottom)
   - 右边框 (xlEdgeRight)

3. 使用了不同的边框粗细：
   - 内部边框使用 xlThin（细线）
   - 外框使用 xlMedium（中等粗线）

这样修改后，每个参数表格都会有：
1. 内部的细边框
2. 外部的粗边框
3. 保持原有的对齐方式和数值格式设置

您可以测试一下，看看效果是否符合要求。如果需要调整边框的粗细，我们可以：
- 将 xlMedium 改为 xlThick 使外框更粗
- 或者调整其他边框相关的属性

---

_**User**_

这个宏不支持哦

---

_**Assistant**_

我明白了，看起来是因为使用了 `Border` 属性而不是 `Borders` 属性导致的问题。让我修改一下代码：

我将修改 `FormatParameterTable` 子程序中的边框设置代码：

---

```diff
          
          ' 设置外框粗边框
-         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeLeft)
-             .LineStyle = xlContinuous
-             .Weight = xlMedium
-         End With
-         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeTop)
-             .LineStyle = xlContinuous
-             .Weight = xlMedium
-         End With
-         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeBottom)
-             .LineStyle = xlContinuous
-             .Weight = xlMedium
-         End With
-         With .Range("B" & startRow & ":G" & (startRow + 13)).Border(xlEdgeRight)
-             .LineStyle = xlContinuous
-             .Weight = xlMedium
+         With .Range("B" & startRow & ":G" & (startRow + 13)).Borders
+             .Item(xlEdgeLeft).LineStyle = xlContinuous
+             .Item(xlEdgeLeft).Weight = xlMedium
+             
+             .Item(xlEdgeTop).LineStyle = xlContinuous
+             .Item(xlEdgeTop).Weight = xlMedium
+             
+             .Item(xlEdgeBottom).LineStyle = xlContinuous
+             .Item(xlEdgeBottom).Weight = xlMedium
+             
+             .Item(xlEdgeRight).LineStyle = xlContinuous
+             .Item(xlEdgeRight).Weight = xlMedium
          End With
          
```

---



我已经修改了代码，主要做了以下更改：

1. 将 `Border` 改为正确的 `Borders` 属性
2. 使用 `.Item()` 方法来访问具体的边框
3. 保持了相同的边框样式（内部细线，外部粗线）

现在代码应该可以正常工作了。这个修改：
1. 使用了正确的 VBA 边框属性语法
2. 保持了原有的边框效果设计
3. 每个表格仍然会有内部细边框和外部粗边框

您可以再次运行代码，看看边框效果是否正常显示了。如果还有任何问题，请告诉我。

---

_**User**_

在单一参数敏感性分析sheet里的每个表格，结果分析行填充蓝色，参数行都填充灰色，变动后的值行填充绿色，每个表格都是这样格式，如图

---

_**Assistant**_

我明白了，您想要为表格添加特定的颜色填充。我会修改 `FormatParameterTable` 子程序来添加这些颜色设置：

---

```diff
              .Item(xlEdgeRight).Weight = xlMedium
          End With
+         
+         ' 设置颜色填充
+         ' 参数名称到原资本金回收期的行填充灰色
+         .Range("B" & startRow & ":G" & (startRow + 5)).Interior.Color = RGB(217, 217, 217)
+         
+         ' 结果分析行填充蓝色
+         .Range("B" & (startRow + 6) & ":G" & (startRow + 6)).Interior.Color = RGB(189, 215, 238)
+         
+         ' 变动后的值行（包括表头）填充绿色
+         .Range("B" & (startRow + 7) & ":G" & (startRow + 13)).Interior.Color = RGB(198, 239, 206)
          
          ' 设置对齐方式
```

---



我已经修改了代码，添加了三种颜色的填充：

1. 灰色 (RGB(217, 217, 217))：
   - 用于参数名称到原资本金回收期的行
   - 包括从表格开始到第6行的内容

2. 蓝色 (RGB(189, 215, 238))：
   - 用于"结果分析"行
   - 对应表格中的第7行

3. 绿色 (RGB(198, 239, 206))：
   - 用于变动后的值部分
   - 包括表头和数据行
   - 从表格的第8行到第14行

这些颜色设置会应用到每个新创建的参数表格中。当您：
1. 创建新的敏感性分析表格时
2. 添加新的参数时
3. 运行计算时

表格都会保持这个统一的颜色格式。您可以测试一下，看看效果是否符合您的要求。如果颜色需要调整，我们可以修改 RGB 值来调整具体的颜色深浅。

---

_**User**_

我想填充浅绿色

---

_**Assistant**_

我来调整绿色的RGB值，使其更浅一些：

---

```diff
          .Range("B" & (startRow + 6) & ":G" & (startRow + 6)).Interior.Color = RGB(189, 215, 238)
          
-         ' 变动后的值行（包括表头）填充绿色
-         .Range("B" & (startRow + 7) & ":G" & (startRow + 13)).Interior.Color = RGB(198, 239, 206)
+         ' 变动后的值行（包括表头）填充浅绿色
+         .Range("B" & (startRow + 7) & ":G" & (startRow + 13)).Interior.Color = RGB(226, 239, 218)
          
          ' 设置对齐方式
```

---



我已经将绿色调整为更浅的色调：
- 原来的绿色是：RGB(198, 239, 206)
- 现在改为：RGB(226, 239, 218)

这个新的颜色值会让绿色看起来更浅，更柔和。您可以测试一下效果，如果还需要调整颜色深浅，请告诉我。

---

_**User**_

CalculateNewValue二义性

---

_**Assistant**_

我明白了，看起来是因为 `CalculateNewValue` 这个函数名在两个不同的地方都有使用，可能会造成二义性。我们需要修改其中一个函数名来避免这个问题。

让我们修改敏感性分析中的函数名：

---

```diff
                  
                  ' 设置变动后全投资IRR公式
-                 .Cells(row, 4).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateNewValue(""" & paramName & """,B" & row & ",""全投资IRR""),""""),"""")"
+                 .Cells(row, 4).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateParameterValue(""" & paramName & """,B" & row & ",""全投资IRR""),""""),"""")"
                  
                  ' 设置变动后资本金IRR公式
-                 .Cells(row, 5).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateNewValue(""" & paramName & """,B" & row & ",""资本金IRR""),""""),"""")"
+                 .Cells(row, 5).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateParameterValue(""" & paramName & """,B" & row & ",""资本金IRR""),""""),"""")"
                  
                  ' 设置变动后全投资回收期公式
-                 .Cells(row, 6).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateNewValue(""" & paramName & """,B" & row & ",""全投回收期""),""""),"""")"
+                 .Cells(row, 6).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateParameterValue(""" & paramName & """,B" & row & ",""全投回收期""),""""),"""")"
                  
                  ' 设置变动后资本金回收期公式
-                 .Cells(row, 7).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateNewValue(""" & paramName & """,B" & row & ",""资本金回收期""),""""),"""")"
+                 .Cells(row, 7).Formula = "=IF(B" & row & "<>"""",IFERROR(CalculateParameterValue(""" & paramName & """,B" & row & ",""资本金回收期""),""""),"""")"
              Next row
          End With
  
  ' 计算新的IRR值
- Public Function CalculateNewValue(ByVal paramType As String, ByVal newValue As Double, ByVal targetType As String) As Double
+ Public Function CalculateParameterValue(ByVal paramType As String, ByVal newValue As Double, ByVal targetType As String) As Double
      Dim baseSheet As Worksheet
      Dim calcSheet As Worksheet
      Select Case targetType
          Case "全投资IRR"
-             CalculateNewValue = baseSheet.Range("N8").Value
+             CalculateParameterValue = baseSheet.Range("N8").Value
          Case "资本金IRR"
-             CalculateNewValue = baseSheet.Range("N10").Value
+             CalculateParameterValue = baseSheet.Range("N10").Value
          Case "全投回收期"
-             CalculateNewValue = baseSheet.Range("N9").Value
+             CalculateParameterValue = baseSheet.Range("N9").Value
          Case "资本金回收期"
-             CalculateNewValue = baseSheet.Range("N11").Value
+             CalculateParameterValue = baseSheet.Range("N11").Value
      End Select
      
                  变化率 = Format((j - 4) * 0.05, "0.00")  ' 转换为字符串格式
                  
-                 .Cells(i, j).Formula = "=计算新IRR(""" & 参数类型 & """, " & 变化率 & ", ""全投资"")"
+                 .Cells(i, j).Formula = "=CalculateParameterValue(""" & 参数类型 & """, " & 变化率 & ", ""全投资"")"
              Next j
          Next i
                  变化率 = Format((j - 4) * 0.05, "0.00")  ' 转换为字符串格式
                  
-                 .Cells(i, j).Formula = "=计算新IRR(""" & 参数类型 & """, " & 变化率 & ", ""资本金"")"
+                 .Cells(i, j).Formula = "=CalculateParameterValue(""" & 参数类型 & """, " & 变化率 & ", ""资本金"")"
              Next j
          Next i
```

---



我已经做了以下修改：

1. 将函数名从 `CalculateNewValue` 改为 `CalculateParameterValue`
2. 更新了所有调用这个函数的地方，包括：
   - 变动后全投资IRR的公式
   - 变动后资本金IRR的公式
   - 变动后全投资回收期的公式
   - 变动后资本金回收期的公式
   - 敏感性分析表格中的计算公式

这样修改后应该可以避免函数名的二义性问题。您可以重新运行代码，看看是否解决了问题。如果还有其他问题，请告诉我。

---

_**User**_

@完整敏感性分析.bas 存储原始值和格式，可不可以存储原公式呢？如果原始值不是数字，而是公式组成的话，是否可以存储以及恢复原公式呢？

---

_**Assistant**_



---

_**User**_

存储原始值和格式，可不可以存储原公式呢？如果原始值不是数字，而是公式组成的话，是否可以存储以及恢复原公式呢？

---

_**Assistant**_

是的，代码中已经实现了存储和恢复原公式的功能。让我来解释一下当前的实现和工作原理：

1. 存储机制：
```vb
With baseSheet.Range("B23")
    oldValue = .Value    ' 存储单元格的当前值
    oldFormula = .Formula  ' 存储单元格的公式
    .Value = newValue    ' 设置新值
End With
```

2. 恢复机制：
```vb
' 恢复原始值时的判断
If oldFormula <> "" Then 
    .Formula = oldFormula  ' 如果有公式，则恢复公式
Else 
    .Value = oldValue     ' 如果没有公式，则恢复值
End If
```

这个机制的工作原理是：

1. 对于普通数值单元格：
   - `.Formula` 将返回空字符串 `""`
   - `.Value` 将返回实际数值
   - 恢复时会走 `else` 分支，直接恢复数值

2. 对于包含公式的单元格：
   - `.Formula` 将返回公式文本（如 `"=A1+B1"`）
   - `.Value` 将返回公式计算后的结果
   - 恢复时会走 `if` 分支，恢复原始公式

举个例子：
```vb
' 假设单元格 B23 包含公式 "=A1+B1"
With baseSheet.Range("B23")
    oldValue = .Value    ' 比如得到 10 (公式计算结果)
    oldFormula = .Formula  ' 得到 "=A1+B1"
    .Value = newValue    ' 临时设置新值
End With

' 后续恢复时
With baseSheet.Range("B23")
    If oldFormula <> "" Then  ' 因为 oldFormula 是 "=A1+B1"，所以这个条件为真
        .Formula = oldFormula  ' 恢复公式 "=A1+B1"
    Else
        .Value = oldValue
    End If
End With
```

这样的设计可以：
1. 正确处理纯数值单元格
2. 正确处理包含公式的单元格
3. 在计算完成后将单元格恢复到其原始状态，无论是数值还是公式

如果您想要进一步加强这个机制，可以考虑：

1. 添加错误处理：
```vb
On Error Resume Next
With baseSheet.Range("B23")
    oldValue = .Value
    oldFormula = .Formula
    If Err.Number = 0 Then
        .Value = newValue
    Else
        Debug.Print "存储原始值/公式时发生错误: " & Err.Description
    End If
End With
On Error GoTo 0
```

2. 添加公式有效性检查：
```vb
With baseSheet.Range("B23")
    oldValue = .Value
    oldFormula = .Formula
    If Left(oldFormula, 1) = "=" Then  ' 确认是有效的公式
        isFormula = True
    End If
    .Value = newValue
End With
```

3. 记录更多信息：
```vb
With baseSheet.Range("B23")
    oldValue = .Value
    oldFormula = .Formula
    oldNumberFormat = .NumberFormat
    oldHasFormula = (Left(.Formula, 1) = "=")
    .Value = newValue
End With
```

这样的机制可以确保在进行敏感性分析时，无论单元格是包含纯数值还是公式，都能正确地保存和恢复原始状态。

---

_**User**_

这里也可以恢复原始公式吗

---

_**Assistant**_

是的，这段代码也实现了恢复原始公式的功能。让我解释一下恢复机制的工作原理：

```vb
With baseSheet.Range("B23")
    If oldFormula <> "" Then 
        .Formula = oldFormula  ' 如果存在公式，则恢复公式
    Else 
        .Value = oldValue     ' 如果没有公式，则恢复数值
    End If
End With
```

对于每个参数单元格，代码都使用了相同的恢复逻辑：

1. 如果 `oldFormula` 不为空字符串（即单元格原本包含公式）：
   - 使用 `.Formula = oldFormula` 恢复原始公式
   - 例如：如果单元格原本包含公式 `"=A1+B1"`，会恢复这个公式

2. 如果 `oldFormula` 为空字符串（即单元格原本只包含数值）：
   - 使用 `.Value = oldValue` 恢复原始数值
   - 例如：如果单元格原本只包含数值 `100`，会恢复这个数值

之后，代码还进行了完整的重新计算：
```vb
' 再次强制计算以确保恢复原状
Application.CalculateFullRebuild
Application.Calculate
calcSheet.Calculate
baseSheet.Calculate
```

这确保了：
1. 所有恢复的公式都被重新计算
2. 所有依赖关系都被正确更新
3. 工作簿回到完全一致的状态

如果您想要进一步加强这个恢复机制，可以考虑添加以下改进：

```vb
' 改进版本的恢复机制
With baseSheet.Range("B23")
    On Error Resume Next
    If oldFormula <> "" Then
        ' 检查是否是有效的Excel公式
        If Left(oldFormula, 1) = "=" Then
            .Formula = oldFormula
            If Err.Number <> 0 Then
                Debug.Print "恢复公式时出错: " & Err.Description
                .Value = oldValue  ' 如果恢复公式失败，退回到使用值
            End If
        Else
            .Value = oldValue
        End If
    Else
        .Value = oldValue
    End If
    On Error GoTo 0
End With
```

这样的改进可以：
1. 更安全地处理公式恢复
2. 在恢复失败时有后备方案
3. 提供更好的错误信息用于调试

您要使用改进版本的恢复机制吗？这样可以让公式的恢复更加可靠。

---

_**User**_

@SensitivityAnalysis.bas 如果原始值不是数字，而是公式组成的话，是否可以存储公式以及恢复原公式呢？

---

_**Assistant**_

我明白了，在 `SensitivityAnalysis.bas` 中，当前的实现只存储了值（`Value`），没有存储公式（`Formula`）。我们需要修改代码来支持公式的存储和恢复。

让我来修改相关代码：

---

```diff
      Dim originalValue As Double
      
-     ' 保存所有可能会改变的参数的原始值
-     Dim orig_发电小时数 As Double
-     Dim orig_电价 As Double
-     Dim orig_消纳率 As Double
-     Dim orig_单位总成本 As Double
-     Dim orig_装机容量 As Double
-     Dim orig_技改费 As Double
-     Dim orig_资本金占比 As Double
-     Dim orig_还款年限 As Double
-     Dim orig_利率 As Double
+     ' 保存所有可能会改变的参数的原始值和公式
+     Dim orig_发电小时数 As Variant
+     Dim orig_电价 As Variant
+     Dim orig_消纳率 As Variant
+     Dim orig_单位总成本 As Variant
+     Dim orig_装机容量 As Variant
+     Dim orig_技改费 As Variant
+     Dim orig_资本金占比 As Variant
+     Dim orig_还款年限 As Variant
+     Dim orig_利率 As Variant
+     
+     Dim orig_发电小时数_Formula As String
+     Dim orig_电价_Formula As String
+     Dim orig_消纳率_Formula As String
+     Dim orig_单位总成本_Formula As String
+     Dim orig_装机容量_Formula As String
+     Dim orig_技改费_Formula As String
+     Dim orig_资本金占比_Formula As String
+     Dim orig_还款年限_Formula As String
+     Dim orig_利率_Formula As String
+ 
+     ' 保存所有参数的原始值和公式
+     With baseSheet
+         orig_发电小时数 = .Range("B23").Value
+         orig_发电小时数_Formula = .Range("B23").Formula
+         
+         orig_电价 = .Range("B42").Value
+         orig_电价_Formula = .Range("B42").Formula
+         
+         orig_消纳率 = .Range("B37").Value
+         orig_消纳率_Formula = .Range("B37").Formula
+         
+         orig_单位总成本 = .Range("F6").Value
+         orig_单位总成本_Formula = .Range("F6").Formula
+         
+         orig_装机容量 = .Range("B12").Value
+         orig_装机容量_Formula = .Range("B12").Formula
+         
+         orig_技改费 = .Range("F25").Value
+         orig_技改费_Formula = .Range("F25").Formula
+         
+         orig_资本金占比 = .Range("J23").Value
+         orig_资本金占比_Formula = .Range("J23").Formula
+         
+         orig_还款年限 = .Range("J26").Value
+         orig_还款年限_Formula = .Range("J26").Formula
+         
+         orig_利率 = .Range("J27").Value
+         orig_利率_Formula = .Range("J27").Formula
+     End With
      
      ' 保存Excel设置
      Set baseSheet = ThisWorkbook.Sheets("基础参数及输出结果表")
      Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
-     
-     ' 保存所有参数的原始值
-     orig_发电小时数 = baseSheet.Range("B23").Value
-     orig_电价 = baseSheet.Range("B42").Value
-     orig_消纳率 = baseSheet.Range("B37").Value
-     orig_单位总成本 = baseSheet.Range("F6").Value
-     orig_装机容量 = baseSheet.Range("B12").Value
-     orig_技改费 = baseSheet.Range("F25").Value
-     orig_资本金占比 = baseSheet.Range("J23").Value
-     orig_还款年限 = baseSheet.Range("J26").Value
-     orig_利率 = baseSheet.Range("J27").Value
      
      ' 从第3行开始查找所有参数表格
                      
                      ' 每次计算完一个值后就恢复原始参数
-                     baseSheet.Range("B23").Value = orig_发电小时数
-                     baseSheet.Range("B42").Value = orig_电价
-                     baseSheet.Range("B37").Value = orig_消纳率
-                     baseSheet.Range("F6").Value = orig_单位总成本
-                     baseSheet.Range("B12").Value = orig_装机容量
-                     baseSheet.Range("F25").Value = orig_技改费
-                     baseSheet.Range("J23").Value = orig_资本金占比
-                     baseSheet.Range("J26").Value = orig_还款年限
-                     baseSheet.Range("J27").Value = orig_利率
+                     With baseSheet
+                         If orig_发电小时数_Formula <> "" Then
+                             .Range("B23").Formula = orig_发电小时数_Formula
+                         Else
+                             .Range("B23").Value = orig_发电小时数
+                         End If
+                         
+                         If orig_电价_Formula <> "" Then
+                             .Range("B42").Formula = orig_电价_Formula
+                         Else
+                             .Range("B42").Value = orig_电价
+                         End If
+                         
+                         If orig_消纳率_Formula <> "" Then
+                             .Range("B37").Formula = orig_消纳率_Formula
+                         Else
+                             .Range("B37").Value = orig_消纳率
+                         End If
+                         
+                         If orig_单位总成本_Formula <> "" Then
+                             .Range("F6").Formula = orig_单位总成本_Formula
+                         Else
+                             .Range("F6").Value = orig_单位总成本
+                         End If
+                         
+                         If orig_装机容量_Formula <> "" Then
+                             .Range("B12").Formula = orig_装机容量_Formula
+                         Else
+                             .Range("B12").Value = orig_装机容量
+                         End If
+                         
+                         If orig_技改费_Formula <> "" Then
+                             .Range("F25").Formula = orig_技改费_Formula
+                         Else
+                             .Range("F25").Value = orig_技改费
+                         End If
+                         
+                         If orig_资本金占比_Formula <> "" Then
+                             .Range("J23").Formula = orig_资本金占比_Formula
+                         Else
+                             .Range("J23").Value = orig_资本金占比
+                         End If
+                         
+                         If orig_还款年限_Formula <> "" Then
+                             .Range("J26").Formula = orig_还款年限_Formula
+                         Else
+                             .Range("J26").Value = orig_还款年限
+                         End If
+                         
+                         If orig_利率_Formula <> "" Then
+                             .Range("J27").Formula = orig_利率_Formula
+                         Else
+                             .Range("J27").Value = orig_利率
+                         End If
+                     End With
                      
                      ' 恢复后重新计算
  ExitSub:
      ' 最后再次确保所有参数都恢复到原始值
-     baseSheet.Range("B23").Value = orig_发电小时数
-     baseSheet.Range("B42").Value = orig_电价
-     baseSheet.Range("B37").Value = orig_消纳率
-     baseSheet.Range("F6").Value = orig_单位总成本
-     baseSheet.Range("B12").Value = orig_装机容量
-     baseSheet.Range("F25").Value = orig_技改费
-     baseSheet.Range("J23").Value = orig_资本金占比
-     baseSheet.Range("J26").Value = orig_还款年限
-     baseSheet.Range("J27").Value = orig_利率
+     With baseSheet
+         If orig_发电小时数_Formula <> "" Then
+             .Range("B23").Formula = orig_发电小时数_Formula
+         Else
+             .Range("B23").Value = orig_发电小时数
+         End If
+         
+         If orig_电价_Formula <> "" Then
+             .Range("B42").Formula = orig_电价_Formula
+         Else
+             .Range("B42").Value = orig_电价
+         End If
+         
+         If orig_消纳率_Formula <> "" Then
+             .Range("B37").Formula = orig_消纳率_Formula
+         Else
+             .Range("B37").Value = orig_消纳率
+         End If
+         
+         If orig_单位总成本_Formula <> "" Then
+             .Range("F6").Formula = orig_单位总成本_Formula
+         Else
+             .Range("F6").Value = orig_单位总成本
+         End If
+         
+         If orig_装机容量_Formula <> "" Then
+             .Range("B12").Formula = orig_装机容量_Formula
+         Else
+             .Range("B12").Value = orig_装机容量
+         End If
+         
+         If orig_技改费_Formula <> "" Then
+             .Range("F25").Formula = orig_技改费_Formula
+         Else
+             .Range("F25").Value = orig_技改费
+         End If
+         
+         If orig_资本金占比_Formula <> "" Then
+             .Range("J23").Formula = orig_资本金占比_Formula
+         Else
+             .Range("J23").Value = orig_资本金占比
+         End If
+         
+         If orig_还款年限_Formula <> "" Then
+             .Range("J26").Formula = orig_还款年限_Formula
+         Else
+             .Range("J26").Value = orig_还款年限
+         End If
+         
+         If orig_利率_Formula <> "" Then
+             .Range("J27").Formula = orig_利率_Formula
+         Else
+             .Range("J27").Value = orig_利率
+         End If
+     End With
      
      ' 最后计算一次以确保所有值都正确
```

---



我已经修改了代码以支持公式的存储和恢复。主要改动包括：

1. 变量声明的改变：
   - 将原来的 `Double` 类型改为 `Variant`，以支持各种可能的值类型
   - 为每个参数添加了对应的 `_Formula` 变量来存储公式

2. 存储逻辑的改变：
   ```vb
   With baseSheet
       orig_发电小时数 = .Range("B23").Value
       orig_发电小时数_Formula = .Range("B23").Formula
       ' ... 其他参数类似
   End With
   ```

3. 恢复逻辑的改变：
   ```vb
   With baseSheet
       If orig_发电小时数_Formula <> "" Then
           .Range("B23").Formula = orig_发电小时数_Formula
       Else
           .Range("B23").Value = orig_发电小时数
       End If
       ' ... 其他参数类似
   End With
   ```

这样修改后，代码可以：
1. 正确存储单元格中的公式（如果存在）
2. 正确存储单元格的值
3. 在恢复时，优先恢复公式（如果原本有公式）
4. 如果原本没有公式，则恢复值

这样就能确保无论单元格中是纯数值还是公式，都能正确地保存和恢复原始状态。

---

_**User**_

报错 with变量未设置

---

_**Assistant**_

啊，我明白了问题所在。在使用 `With baseSheet` 之前，我们还没有设置 `baseSheet` 变量。让我来修复这个问题：

---

```diff
      Dim orig_还款年限_Formula As String
      Dim orig_利率_Formula As String
+ 
+     ' 保存Excel设置
+     oldCalculation = Application.calculation
+     oldScreenUpdating = Application.screenUpdating
+     
+     ' 优化性能设置
+     Application.screenUpdating = False
+     Application.calculation = xlCalculationManual
+     
+     Set ws = ThisWorkbook.Sheets("单一参数敏感性分析")
+     Set baseSheet = ThisWorkbook.Sheets("基础参数及输出结果表")
+     Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
  
      ' 保存所有参数的原始值和公式
          orig_利率_Formula = .Range("J27").Formula
      End With
-     
-     ' 保存Excel设置
-     oldCalculation = Application.calculation
-     oldScreenUpdating = Application.screenUpdating
-     
-     ' 优化性能设置
-     Application.screenUpdating = False
-     Application.calculation = xlCalculationManual
-     
-     Set ws = ThisWorkbook.Sheets("单一参数敏感性分析")
-     Set baseSheet = ThisWorkbook.Sheets("基础参数及输出结果表")
-     Set calcSheet = ThisWorkbook.Sheets("光伏收益测算表")
      
      ' 从第3行开始查找所有参数表格
```

---



我已经修改了代码，主要做了以下改动：

1. 将工作表对象的设置（`Set ws`, `Set baseSheet`, `Set calcSheet`）移到了 `With baseSheet` 语句之前
2. 将 Excel 设置的保存和优化性能设置也移到了前面

这样修改后，在使用 `With baseSheet` 语句时，`baseSheet` 变量已经被正确设置，就不会出现"变量未设置"的错误了。

现在代码的执行顺序更加合理：
1. 先声明所有变量
2. 保存和设置 Excel 环境参数
3. 设置所有需要的工作表对象
4. 使用 `With` 语句保存参数的原始值和公式
5. 继续执行后续的计算逻辑

这样的修改应该能解决你遇到的错误。你可以再次运行代码，看看是否还有其他问题。

---



---

